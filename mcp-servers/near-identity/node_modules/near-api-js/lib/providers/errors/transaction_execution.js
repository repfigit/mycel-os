import { RpcError } from './rpc.js';
export class TransactionExecutionError extends RpcError {
    constructor(message, txHash, blockHash) {
        super(message);
        this.txHash = txHash;
        this.blockHash = blockHash;
    }
}
export class ActionExecutionError extends TransactionExecutionError {
    constructor(message, actionIndex, txHash, blockHash) {
        super(message, txHash, blockHash);
        this.actionIndex = actionIndex;
    }
}
export class AccountAlreadyExistsActionError extends ActionExecutionError {
    constructor(accountId, actionIndex, txHash, blockHash) {
        super(`Account ${accountId} already exists`, actionIndex, txHash, blockHash);
        this.accountId = accountId;
    }
}
export class AccountDoesNotExistActionError extends ActionExecutionError {
    constructor(accountId, actionIndex, txHash, blockHash) {
        super(`Account ${accountId} does not exist`, actionIndex, txHash, blockHash);
        this.accountId = accountId;
    }
}
export class ActorNoPermissionActionError extends ActionExecutionError {
    constructor(accountId, actorId, actionIndex, txHash, blockHash) {
        super(`Actor ${actorId} has no permission on account ${accountId}`, actionIndex, txHash, blockHash);
        this.accountId = accountId;
        this.actorId = actorId;
    }
}
export class AddKeyAlreadyExistsActionError extends ActionExecutionError {
    constructor(accountId, publicKey, actionIndex, txHash, blockHash) {
        super(`Public key ${publicKey} already exists on account ${accountId}`, actionIndex, txHash, blockHash);
        this.accountId = accountId;
        this.publicKey = publicKey;
    }
}
export class DeleteKeyDoesNotExistActionError extends ActionExecutionError {
    constructor(accountId, publicKey, actionIndex, txHash, blockHash) {
        super(`Public key ${publicKey} does not exist on account ${accountId}`, actionIndex, txHash, blockHash);
        this.accountId = accountId;
        this.publicKey = publicKey;
    }
}
export class DeleteAccountStakingActionError extends ActionExecutionError {
    constructor(accountId, actionIndex, txHash, blockHash) {
        super(`Account ${accountId} cannot be deleted because it is staking`, actionIndex, txHash, blockHash);
        this.accountId = accountId;
    }
}
export class LackBalanceForStateActionError extends ActionExecutionError {
    constructor(accountId, amount, actionIndex, txHash, blockHash) {
        super(`Account ${accountId} lacks balance ${amount.toString()} yoctoNear for state`, actionIndex, txHash, blockHash);
        this.accountId = accountId;
        this.amount = amount;
    }
}
export class TriesToUnstakeActionError extends ActionExecutionError {
    constructor(accountId, actionIndex, txHash, blockHash) {
        super(`Account ${accountId} tries to unstake`, actionIndex, txHash, blockHash);
        this.accountId = accountId;
    }
}
export class TriesToStakeActionError extends ActionExecutionError {
    constructor(accountId, balance, locked, stake, actionIndex, txHash, blockHash) {
        super(`Invalid stake attempt for ${accountId} (balance: ${balance}, locked: ${locked}, stake: ${stake})`, actionIndex, txHash, blockHash);
        this.accountId = accountId;
        this.balance = balance;
        this.locked = locked;
        this.stake = stake;
    }
}
export class InsufficientStakeActionError extends ActionExecutionError {
    constructor(accountId, minimumStake, stake, actionIndex, txHash, blockHash) {
        super(`Insufficient stake for ${accountId} (minimum: ${minimumStake}, stake: ${stake})`, actionIndex, txHash, blockHash);
        this.accountId = accountId;
        this.minimumStake = minimumStake;
        this.stake = stake;
    }
}
export class OnlyImplicitAccountCreationAllowedActionError extends ActionExecutionError {
    constructor(accountId, actionIndex, txHash, blockHash) {
        super(`Only implicit account creation allowed for ${accountId}`, actionIndex, txHash, blockHash);
        this.accountId = accountId;
    }
}
export class DeleteAccountWithLargeStateActionError extends ActionExecutionError {
    constructor(accountId, actionIndex, txHash, blockHash) {
        super(`Account ${accountId} cannot be deleted because it has a large state`, actionIndex, txHash, blockHash);
        this.accountId = accountId;
    }
}
export class DelegateActionInvalidSignatureActionError extends ActionExecutionError {
    constructor(actionIndex, txHash, blockHash) {
        super(`Delegate action has an invalid signature`, actionIndex, txHash, blockHash);
    }
}
export class DelegateActionExpiredActionError extends ActionExecutionError {
    constructor(actionIndex, txHash, blockHash) {
        super(`Delegate action has expired`, actionIndex, txHash, blockHash);
    }
}
export class DelegateActionInvalidNonceActionError extends ActionExecutionError {
    constructor(akNonce, delegateNonce, actionIndex, txHash, blockHash) {
        super(`Invalid delegate nonce (ak: ${akNonce}, delegate: ${delegateNonce})`, actionIndex, txHash, blockHash);
        this.akNonce = akNonce;
        this.delegateNonce = delegateNonce;
    }
}
export class DelegateActionNonceTooLargeActionError extends ActionExecutionError {
    constructor(delegateNonce, upperBound, actionIndex, txHash, blockHash) {
        super(`Delegate nonce ${delegateNonce} exceeds upper bound ${upperBound}`, actionIndex, txHash, blockHash);
        this.delegateNonce = delegateNonce;
        this.upperBound = upperBound;
    }
}
export class GasKeyDoesNotExistActionError extends ActionExecutionError {
    constructor(accountId, publicKey, actionIndex, txHash, blockHash) {
        super(`Gas key ${publicKey} does not exist on account ${accountId}`, actionIndex, txHash, blockHash);
        this.accountId = accountId;
        this.publicKey = publicKey;
    }
}
export class GasKeyAlreadyExistsActionError extends ActionExecutionError {
    constructor(accountId, publicKey, actionIndex, txHash, blockHash) {
        super(`Gas key ${publicKey} already exists on account ${accountId}`, actionIndex, txHash, blockHash);
        this.accountId = accountId;
        this.publicKey = publicKey;
    }
}
export class GlobalContractDoesNotExistActionError extends ActionExecutionError {
    constructor(identifier, actionIndex, txHash, blockHash) {
        super(`Global contract ${identifier} does not exist`, actionIndex, txHash, blockHash);
        this.identifier = identifier;
    }
}
export class CreateAccountOnlyByRegistrarActionError extends ActionExecutionError {
    constructor(accountId, predecessorId, registrarAccountId, actionIndex, txHash, blockHash) {
        super(`Account ${accountId} can only be created by registrar ${registrarAccountId}, but was attempted by ${predecessorId}`, actionIndex, txHash, blockHash);
        this.accountId = accountId;
        this.predecessorId = predecessorId;
        this.registrarAccountId = registrarAccountId;
    }
}
export class CreateAccountNotAllowedActionError extends ActionExecutionError {
    constructor(accountId, predecessorId, actionIndex, txHash, blockHash) {
        super(`Account ${accountId} cannot be created by ${predecessorId}`, actionIndex, txHash, blockHash);
        this.accountId = accountId;
        this.predecessorId = predecessorId;
    }
}
export class DelegateActionSenderDoesNotMatchTxReceiverActionError extends ActionExecutionError {
    constructor(receiverId, senderId, actionIndex, txHash, blockHash) {
        super(`Delegate action sender ${senderId} does not match transaction receiver ${receiverId}`, actionIndex, txHash, blockHash);
        this.receiverId = receiverId;
        this.senderId = senderId;
    }
}
export class AccessKeyNotFoundActionError extends ActionExecutionError {
    constructor(accountId, publicKey, actionIndex, txHash, blockHash) {
        super(`Access key ${publicKey} does not exist on account ${accountId}`, actionIndex, txHash, blockHash);
        this.accountId = accountId;
        this.publicKey = publicKey;
    }
}
export class AccessKeyReceiverMismatchActionError extends ActionExecutionError {
    constructor(akReceiver, txReceiver, actionIndex, txHash, blockHash) {
        super(`Access key receiver ${akReceiver} does not match transaction receiver ${txReceiver}`, actionIndex, txHash, blockHash);
        this.akReceiver = akReceiver;
        this.txReceiver = txReceiver;
    }
}
export class AccessKeyMethodNameMismatchActionError extends ActionExecutionError {
    constructor(methodName, actionIndex, txHash, blockHash) {
        super(`Access key does not allow method ${methodName}`, actionIndex, txHash, blockHash);
        this.methodName = methodName;
    }
}
export class AccessKeyRequiresFullAccessActionError extends ActionExecutionError {
    constructor(actionIndex, txHash, blockHash) {
        super(`Access key requires full access`, actionIndex, txHash, blockHash);
    }
}
export class AccessKeyNotEnoughAllowanceActionError extends ActionExecutionError {
    constructor(accountId, allowance, cost, publicKey, actionIndex, txHash, blockHash) {
        super(`Not enough allowance for access key ${publicKey} on account ${accountId} (allowance: ${allowance}, cost: ${cost})`, actionIndex, txHash, blockHash);
        this.accountId = accountId;
        this.allowance = allowance;
        this.cost = cost;
        this.publicKey = publicKey;
    }
}
export class AccessKeyDepositWithFunctionCallActionError extends ActionExecutionError {
    constructor(actionIndex, txHash, blockHash) {
        super(`Deposit is not allowed with function call`, actionIndex, txHash, blockHash);
    }
}
export class InvalidPredecessorIdReceiptActionError extends ActionExecutionError {
    constructor(accountId, actionIndex, txHash, blockHash) {
        super(`Invalid predecessor ID: ${accountId}`, actionIndex, txHash, blockHash);
    }
}
export class InvalidReceiverIdReceiptActionError extends ActionExecutionError {
    constructor(accountId, actionIndex, txHash, blockHash) {
        super(`Invalid receiver ID: ${accountId}`, actionIndex, txHash, blockHash);
    }
}
export class InvalidSignerIdReceiptActionError extends ActionExecutionError {
    constructor(accountId, actionIndex, txHash, blockHash) {
        super(`Invalid signer ID: ${accountId}`, actionIndex, txHash, blockHash);
    }
}
export class InvalidDataReceiverIdReceiptActionError extends ActionExecutionError {
    constructor(accountId, actionIndex, txHash, blockHash) {
        super(`Invalid data receiver ID: ${accountId}`, actionIndex, txHash, blockHash);
    }
}
export class ReturnedValueLengthExceededReceiptActionError extends ActionExecutionError {
    constructor(length, limit, actionIndex, txHash, blockHash) {
        super(`Returned value length ${length} exceeds limit ${limit}`, actionIndex, txHash, blockHash);
    }
}
export class NumberInputDataDependenciesExceededReceiptActionError extends ActionExecutionError {
    constructor(limit, count, actionIndex, txHash, blockHash) {
        super(`Number of input data dependencies ${count} exceeds limit ${limit}`, actionIndex, txHash, blockHash);
    }
}
export class ReceiptSizeExceededActionError extends ActionExecutionError {
    constructor(limit, size, actionIndex, txHash, blockHash) {
        super(`Receipt size ${size} exceeds limit ${limit}`, actionIndex, txHash, blockHash);
    }
}
export class InvalidRefundToReceiptActionError extends ActionExecutionError {
    constructor(accountId, actionIndex, txHash, blockHash) {
        super(`Invalid refund-to account ID: ${accountId}`, actionIndex, txHash, blockHash);
    }
}
export class DeleteActionMustBeFinalActionError extends ActionExecutionError {
    constructor(actionIndex, txHash, blockHash) {
        super(`Delete action must be final`, actionIndex, txHash, blockHash);
    }
}
export class TotalPrepaidGasExceededActionError extends ActionExecutionError {
    constructor(limit, total, actionIndex, txHash, blockHash) {
        super(`Total prepaid gas ${total} exceeds limit ${limit}`, actionIndex, txHash, blockHash);
    }
}
export class TotalNumberOfActionsExceededActionError extends ActionExecutionError {
    constructor(limit, total, actionIndex, txHash, blockHash) {
        super(`Total number of actions ${total} exceeds limit ${limit}`, actionIndex, txHash, blockHash);
    }
}
export class AddKeyMethodNamesNumberOfBytesExceededActionError extends ActionExecutionError {
    constructor(limit, totalBytes, actionIndex, txHash, blockHash) {
        super(`Total method name bytes ${totalBytes} exceed limit ${limit}`, actionIndex, txHash, blockHash);
    }
}
export class AddKeyMethodNameLengthExceededActionError extends ActionExecutionError {
    constructor(length, limit, actionIndex, txHash, blockHash) {
        super(`Method name length ${length} exceeds limit ${limit}`, actionIndex, txHash, blockHash);
    }
}
export class IntegerOverflowValidationActionError extends ActionExecutionError {
    constructor(actionIndex, txHash, blockHash) {
        super(`Integer overflow during action validation`, actionIndex, txHash, blockHash);
    }
}
export class InvalidAccountIdValidationActionError extends ActionExecutionError {
    constructor(accountId, actionIndex, txHash, blockHash) {
        super(`Invalid account ID: ${accountId}`, actionIndex, txHash, blockHash);
    }
}
export class ContractSizeExceededValidationActionError extends ActionExecutionError {
    constructor(limit, size, actionIndex, txHash, blockHash) {
        super(`Contract size ${size} exceeds limit ${limit}`, actionIndex, txHash, blockHash);
    }
}
export class FunctionCallMethodNameLengthExceededActionError extends ActionExecutionError {
    constructor(length, limit, actionIndex, txHash, blockHash) {
        super(`Function method name length ${length} exceeds limit ${limit}`, actionIndex, txHash, blockHash);
    }
}
export class FunctionCallArgumentsLengthExceededActionError extends ActionExecutionError {
    constructor(length, limit, actionIndex, txHash, blockHash) {
        super(`Function call arguments length ${length} exceeds limit ${limit}`, actionIndex, txHash, blockHash);
    }
}
export class UnsuitableStakingKeyActionError extends ActionExecutionError {
    constructor(publicKey, actionIndex, txHash, blockHash) {
        super(`Unsuitable staking key ${publicKey}`, actionIndex, txHash, blockHash);
    }
}
export class FunctionCallZeroAttachedGasActionError extends ActionExecutionError {
    constructor(actionIndex, txHash, blockHash) {
        super(`Function call has zero attached gas`, actionIndex, txHash, blockHash);
    }
}
export class DelegateActionMustBeOnlyOneActionError extends ActionExecutionError {
    constructor(actionIndex, txHash, blockHash) {
        super(`Delegate action must be the only action in transaction`, actionIndex, txHash, blockHash);
    }
}
export class UnsupportedProtocolFeatureActionError extends ActionExecutionError {
    constructor(feature, version, actionIndex, txHash, blockHash) {
        super(`Unsupported protocol feature ${feature} (version ${version})`, actionIndex, txHash, blockHash);
    }
}
export class InvalidDeterministicStateInitReceiverActionError extends ActionExecutionError {
    constructor(derived, receiver, actionIndex, txHash, blockHash) {
        super(`Invalid deterministic state init receiver ${receiver} (derived ${derived})`, actionIndex, txHash, blockHash);
    }
}
export class DeterministicStateInitKeyLengthExceededActionError extends ActionExecutionError {
    constructor(length, limit, actionIndex, txHash, blockHash) {
        super(`Deterministic state init key length ${length} exceeds limit ${limit}`, actionIndex, txHash, blockHash);
    }
}
export class DeterministicStateInitValueLengthExceededActionError extends ActionExecutionError {
    constructor(length, limit, actionIndex, txHash, blockHash) {
        super(`Deterministic state init value length ${length} exceeds limit ${limit}`, actionIndex, txHash, blockHash);
    }
}
export class GasKeyPermissionInvalidActionError extends ActionExecutionError {
    constructor(permission, actionIndex, txHash, blockHash) {
        super(`Invalid gas key permission`, actionIndex, txHash, blockHash);
        this.permission = permission;
    }
}
export class GasKeyTooManyNoncesRequestedActionError extends ActionExecutionError {
    constructor(limit, requested, actionIndex, txHash, blockHash) {
        super(`Requested ${requested} nonces exceeds limit ${limit}`, actionIndex, txHash, blockHash);
    }
}
export class InvalidSignerIdError extends TransactionExecutionError {
    constructor(signerId, txHash, blockHash) {
        super(`Invalid signer ID: ${signerId}`, txHash, blockHash);
        this.signerId = signerId;
    }
}
export class SignerDoesNotExistError extends TransactionExecutionError {
    constructor(signerId, txHash, blockHash) {
        super(`Signer ${signerId} does not exist`, txHash, blockHash);
        this.signerId = signerId;
    }
}
export class InvalidNonceError extends TransactionExecutionError {
    constructor(accessKeyNonce, transactionNonce, txHash, blockHash) {
        super(`Invalid nonce (ak: ${accessKeyNonce}, tx: ${transactionNonce})`, txHash, blockHash);
        this.accessKeyNonce = accessKeyNonce;
        this.transactionNonce = transactionNonce;
    }
}
export class NonceTooLargeError extends TransactionExecutionError {
    constructor(transactionNonce, upperBound, txHash, blockHash) {
        super(`Transaction nonce ${transactionNonce} exceeds upper bound ${upperBound}`, txHash, blockHash);
        this.transactionNonce = transactionNonce;
        this.upperBound = upperBound;
    }
}
export class InvalidReceiverIdError extends TransactionExecutionError {
    constructor(receiverId, txHash, blockHash) {
        super(`Invalid receiver ID: ${receiverId}`, txHash, blockHash);
        this.receiverId = receiverId;
    }
}
export class InvalidSignatureError extends TransactionExecutionError {
    constructor(txHash, blockHash) {
        super(`Invalid transaction signature`, txHash, blockHash);
    }
}
export class NotEnoughBalanceError extends TransactionExecutionError {
    constructor(balance, cost, signerId, txHash, blockHash) {
        super(`Not enough balance for ${signerId} (balance: ${balance}, cost: ${cost})`, txHash, blockHash);
        this.balance = balance;
        this.cost = cost;
        this.signerId = signerId;
    }
}
export class CostOverflowError extends TransactionExecutionError {
    constructor(txHash, blockHash) {
        super(`Transaction cost overflow`, txHash, blockHash);
    }
}
export class InvalidChainError extends TransactionExecutionError {
    constructor(txHash, blockHash) {
        super(`Invalid chain ID`, txHash, blockHash);
    }
}
export class TransactionExpiredError extends TransactionExecutionError {
    constructor(txHash, blockHash) {
        super(`Transaction expired`, txHash, blockHash);
    }
}
export class TransactionSizeExceededError extends TransactionExecutionError {
    constructor(limit, size, txHash, blockHash) {
        super(`Transaction size ${size} exceeds limit ${limit}`, txHash, blockHash);
        this.limit = limit;
        this.size = size;
    }
}
export class InvalidTransactionVersionError extends TransactionExecutionError {
    constructor(txHash, blockHash) {
        super(`Invalid transaction version`, txHash, blockHash);
    }
}
export class StorageInternalError extends TransactionExecutionError {
    constructor(txHash, blockHash) {
        super(`Internal storage error`, txHash, blockHash);
    }
}
export class MissingTrieValueError extends TransactionExecutionError {
    constructor(context, hash, txHash, blockHash) {
        super(`Missing trie value ${hash}`, txHash, blockHash);
        this.context = context;
        this.hash = hash;
    }
}
export class UnexpectedTrieValueError extends TransactionExecutionError {
    constructor(txHash, blockHash) {
        super(`Unexpected trie value`, txHash, blockHash);
    }
}
export class StorageInconsistentStateError extends TransactionExecutionError {
    constructor(details, txHash, blockHash) {
        super(`Storage inconsistent state: ${details}`, txHash, blockHash);
        this.details = details;
    }
}
export class FlatStorageBlockNotSupportedError extends TransactionExecutionError {
    constructor(details, txHash, blockHash) {
        super(`Flat storage block not supported: ${details}`, txHash, blockHash);
        this.details = details;
    }
}
export class MemTrieLoadingError extends TransactionExecutionError {
    constructor(details, txHash, blockHash) {
        super(`MemTrie loading error: ${details}`, txHash, blockHash);
        this.details = details;
    }
}
export class ShardCongestedError extends TransactionExecutionError {
    constructor(congestionLevel, shardId, txHash, blockHash) {
        super(`Shard ${shardId} congested (level: ${congestionLevel})`, txHash, blockHash);
        this.congestionLevel = congestionLevel;
        this.shardId = shardId;
    }
}
export class ShardStuckError extends TransactionExecutionError {
    constructor(missedChunks, shardId, txHash, blockHash) {
        super(`Shard ${shardId} stuck (missed chunks: ${missedChunks})`, txHash, blockHash);
        this.missedChunks = missedChunks;
        this.shardId = shardId;
    }
}
