import { RpcError } from './rpc.js';
export class HandlerError extends RpcError {
}
export class AccountDoesNotExistError extends HandlerError {
    constructor(accountId, blockHash, blockHeight) {
        super(`Account ${accountId} does not exist at block height ${blockHeight}`);
        this.accountId = accountId;
        this.blockHash = blockHash;
        this.blockHeight = blockHeight;
    }
}
export class AccessKeyDoesNotExistError extends HandlerError {
    constructor(publicKey, blockHash, blockHeight) {
        super(`Access key ${publicKey.toString()} does not exist at block height ${blockHeight}`);
        this.publicKey = publicKey;
        this.blockHash = blockHash;
        this.blockHeight = blockHeight;
    }
}
export class UnknownBlockError extends HandlerError {
    constructor(blockReference) {
        let metadata = '';
        if (typeof blockReference === 'object' && 'block_id' in blockReference) {
            metadata = `block = ${blockReference.block_id}`;
        }
        else if (typeof blockReference === 'object' && 'finality' in blockReference) {
            metadata = `finality = ${blockReference.finality}`;
        }
        else if (typeof blockReference === 'object' && 'sync_checkpoint' in blockReference) {
            metadata = `sync checkpoint = ${blockReference.sync_checkpoint}`;
        }
        super(`Block either has never been observed on the node or has been garbage collected ${metadata ? `(${metadata})` : ''}`.trimEnd());
        this.blockReference = blockReference;
    }
}
export class GasKeyDoesNotExistError extends HandlerError {
    constructor(publicKey, blockHash, blockHeight) {
        super(`Gas key for public key ${publicKey.toString()} does not exist at block height ${blockHeight}`);
        this.publicKey = publicKey;
        this.blockHash = blockHash;
        this.blockHeight = blockHeight;
    }
}
export class GlobalContractCodeDoesNotExistError extends HandlerError {
    constructor(identifier, blockHash, blockHeight) {
        super(`Global contract code does not exist at block height ${blockHeight}`);
        this.identifier = identifier;
        this.blockHash = blockHash;
        this.blockHeight = blockHeight;
    }
}
export class GarbageCollectedBlockError extends HandlerError {
    constructor(blockHash, blockHeight) {
        super(`Block ${blockHash} has been garbage collected`);
        this.blockHash = blockHash;
        this.blockHeight = blockHeight;
    }
}
export class InvalidShardIdError extends HandlerError {
    constructor(shardId) {
        super(`Invalid shard id ${shardId}`);
        this.shardId = shardId;
    }
}
export class UnavailableShardError extends HandlerError {
    constructor(shardId) {
        super(`Shard ${shardId} is unavailable`);
        this.shardId = shardId;
    }
}
export class InvalidTransactionError extends HandlerError {
    constructor() {
        super(`Invalid transaction`);
    }
}
export class UnknownTransactionError extends HandlerError {
    constructor(txHash) {
        super(`Unknown transaction ${txHash}`);
        this.txHash = txHash;
    }
}
export class TransactionTimeoutError extends HandlerError {
    constructor() {
        super(`Transaction timed out`);
    }
}
export class UnknownEpochError extends HandlerError {
    constructor() {
        super(`Unknown epoch`);
    }
}
export class EpochOutOfBoundsError extends HandlerError {
    constructor(epochId) {
        super(`Epoch ${epochId} is out of bounds`);
        this.epochId = epochId;
    }
}
export class NodeIsSyncingError extends HandlerError {
    constructor() {
        super(`Node is syncing`);
    }
}
export class NoNewBlocksError extends HandlerError {
    constructor() {
        super(`No new blocks produced`);
    }
}
export class UnknownReceiptError extends HandlerError {
    constructor(receiptId) {
        super(`Unknown receipt ${receiptId}`);
        this.receiptId = receiptId;
    }
}
export class InternalHandlerError extends HandlerError {
}
export class NotSyncedYetError extends HandlerError {
    constructor() {
        super(`Node is not synced yet`);
    }
}
export class UnknownChunkError extends HandlerError {
    constructor(chunkHash) {
        super(`Unknown chunk ${chunkHash}`);
        this.chunkHash = chunkHash;
    }
}
export class DoesNotTrackShardError extends HandlerError {
    constructor() {
        super(`Node does not track this shard`);
    }
}
export class RequestRoutedError extends HandlerError {
    constructor(transactionHash) {
        super(`Request was routed for transaction ${transactionHash}`);
        this.transactionHash = transactionHash;
    }
}
export class ValidatorInfoUnavailableError extends HandlerError {
    constructor() {
        super(`Validator info is unavailable`);
    }
}
export class NoSyncedBlocksError extends HandlerError {
    constructor() {
        super(`No synced blocks available`);
    }
}
export class InvalidAccountError extends HandlerError {
    constructor(requestedAccountId, blockHash, blockHeight) {
        super(`Invalid account ${requestedAccountId} at block height ${blockHeight}`);
        this.requestedAccountId = requestedAccountId;
        this.blockHash = blockHash;
        this.blockHeight = blockHeight;
    }
}
export class TooLargeContractStateError extends HandlerError {
    constructor(contractAccountId, blockHash, blockHeight) {
        super(`Contract state for ${contractAccountId} is too large at block height ${blockHeight}`);
        this.contractAccountId = contractAccountId;
        this.blockHash = blockHash;
        this.blockHeight = blockHeight;
    }
}
export class InconsistentStateError extends HandlerError {
    constructor(executionOutcomeShardId, numberOfShards) {
        super(`Inconsistent state: outcome shard ${executionOutcomeShardId}, number of shards ${numberOfShards}`);
        this.executionOutcomeShardId = executionOutcomeShardId;
        this.numberOfShards = numberOfShards;
    }
}
export class NotConfirmedError extends HandlerError {
    constructor(transactionOrReceiptId) {
        super(`Transaction or receipt ${transactionOrReceiptId} is not confirmed`);
        this.transactionOrReceiptId = transactionOrReceiptId;
    }
}
export class UnknownTransactionOrReceiptError extends HandlerError {
    constructor(transactionOrReceiptId) {
        super(`Unknown transaction or receipt ${transactionOrReceiptId}`);
        this.transactionOrReceiptId = transactionOrReceiptId;
    }
}
