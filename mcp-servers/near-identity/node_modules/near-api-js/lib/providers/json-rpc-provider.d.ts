/**
 * @module
 * @description
 * This module contains the {@link JsonRpcProvider} client class
 * which can be used to interact with the [NEAR RPC API](https://docs.near.org/api/rpc/introduction).
 * @see {@link "@near-js/types".provider | provider} for a list of request and response types
 */
import type { AccessKeyList, CallResult, CryptoHash, RpcBlockResponse, RpcChunkResponse, RpcGasPriceResponse, RpcLightClientExecutionProofResponse, RpcLightClientNextBlockResponse, RpcProtocolConfigResponse, RpcQueryRequest, RpcQueryResponse, RpcReceiptResponse, RpcStateChangesInBlockByTypeResponse, RpcStateChangesInBlockResponse, RpcStatusResponse, RpcTransactionResponse, RpcValidatorResponse, ViewStateResult } from '../rpc/index.js';
import { type SignedTransaction } from '../transactions/index.js';
import { type AccessKeyWithPublicKey, type BlockId, type BlockReference, type ChunkId, type LightClientProofRequest, type NextLightClientBlockRequest, type SerializedReturnValue, type TxExecutionStatus } from '../types/index.js';
import { type ConnectionInfo } from './fetch_json.js';
import type { Methods } from './methods.js';
import type { CallFunctionArgs, Provider, ViewAccessKeyArgs, ViewAccessKeyListArgs, ViewAccountArgs, ViewContractCodeArgs, ViewContractStateArgs, ViewGlobalContractCodeArgs, ViewTransactionStatusArgs, ViewValidatorsArgs } from './provider.js';
type RequestOptions = {
    /**
     * Number of retries before giving up on a request
     */
    retries: number;
    /**
     * Wait until next retry in milliseconds
     */
    wait: number;
    /**
     * Exponential back off for waiting to retry again
     */
    backoff: number;
};
/**
 * Client class to interact with the [NEAR RPC API](https://docs.near.org/api/rpc/introduction).
 * @see [https://github.com/near/nearcore/tree/master/chain/jsonrpc](https://github.com/near/nearcore/tree/master/chain/jsonrpc)
 */
export declare class JsonRpcProvider implements Provider {
    /** @hidden */
    readonly connection: ConnectionInfo;
    /** @hidden */
    readonly options: RequestOptions;
    /** @hidden */
    private networkId;
    /**
     * @param connectionInfo Connection info
     */
    constructor(connectionInfo: ConnectionInfo, options?: Partial<RequestOptions>);
    getNetworkId(): Promise<string>;
    getCurrentEpochSeatPrice(): Promise<bigint>;
    getNextEpochSeatPrice(): Promise<bigint>;
    viewAccessKey({ accountId, publicKey, finalityQuery, }: ViewAccessKeyArgs): Promise<{
        nonce: bigint;
        permission: import("../rpc/types.gen.js").AccessKeyPermissionView;
        block_hash: CryptoHash;
        block_height: number;
    }>;
    viewAccessKeyList({ accountId, finalityQuery, }: ViewAccessKeyListArgs): Promise<AccessKeyList & {
        block_hash: CryptoHash;
        block_height: number;
    }>;
    viewAccount({ accountId, blockQuery }: ViewAccountArgs): Promise<{
        amount: bigint;
        locked: bigint;
        code_hash: CryptoHash;
        global_contract_account_id?: import("../rpc/types.gen.js").AccountId | null;
        global_contract_hash?: CryptoHash | null;
        storage_paid_at?: number;
        storage_usage: number;
        block_hash: CryptoHash;
        block_height: number;
    }>;
    viewContractCode({ contractId, blockQuery }: ViewContractCodeArgs): Promise<{
        code: Uint8Array<ArrayBuffer>;
        code_base64: string;
        hash: CryptoHash;
        block_hash: CryptoHash;
        block_height: number;
    }>;
    viewGlobalContractCode({ identifier, blockQuery, }: ViewGlobalContractCodeArgs): Promise<{
        code: Uint8Array<ArrayBuffer>;
        code_base64: string;
        hash: CryptoHash;
        block_hash: CryptoHash;
        block_height: number;
    }>;
    viewContractState({ contractId, prefix, blockQuery, }: ViewContractStateArgs): Promise<ViewStateResult & {
        block_hash: CryptoHash;
        block_height: number;
    }>;
    callFunction<T extends SerializedReturnValue>({ contractId, method, args, blockQuery, }: CallFunctionArgs): Promise<T | undefined>;
    callFunctionRaw({ contractId, method, args, blockQuery, }: CallFunctionArgs): Promise<CallResult & {
        block_hash: CryptoHash;
        block_height: number;
    }>;
    viewBlock(blockQuery: BlockReference): Promise<RpcBlockResponse>;
    viewChunk(chunkId: ChunkId): Promise<RpcChunkResponse>;
    viewGasPrice(blockId?: BlockId): Promise<RpcGasPriceResponse>;
    viewNodeStatus(): Promise<RpcStatusResponse>;
    /**
     * Query validators of an epoch.
     * @see [https://docs.near.org/api/rpc/network#validation-status](https://docs.near.org/api/rpc/network#validation-status)
     *
     * @param params Object specifying either a block or epoch to query.
     * - `{ blockId }`: Block hash or height.
     * - `{ epochId }`: Epoch hash.
     * - `null`: Current epoch.
     */
    viewValidators(params?: ViewValidatorsArgs): Promise<RpcValidatorResponse>;
    viewTransactionStatus({ txHash, accountId, waitUntil, }: ViewTransactionStatusArgs): Promise<RpcTransactionResponse>;
    viewTransactionStatusWithReceipts({ txHash, accountId, waitUntil, }: ViewTransactionStatusArgs): Promise<RpcTransactionResponse>;
    viewTransactionReceipt(receiptId: string): Promise<RpcReceiptResponse>;
    /**
     * Sends a signed transaction to the RPC
     *
     * @param signedTransaction The signed transaction being sent
     * @param waitUntil
     */
    sendTransactionUntil(signedTransaction: SignedTransaction, waitUntil: TxExecutionStatus): Promise<RpcTransactionResponse>;
    /**
     * Sends a signed transaction to the RPC and waits until transaction is fully complete
     * @see [https://docs.near.org/docs/develop/front-end/rpc#send-transaction-await](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
     *
     * @param signedTransaction The signed transaction being sent
     */
    sendTransaction(signedTransaction: SignedTransaction): Promise<RpcTransactionResponse>;
    /**
     * Sends a signed transaction to the RPC and immediately returns transaction hash
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#send-transaction-async)
     * @param signedTransaction The signed transaction being sent
     * @returns {Promise<FinalExecutionOutcome>}
     */
    sendTransactionAsync(signedTransaction: SignedTransaction): Promise<RpcTransactionResponse>;
    /**
     * Query the RPC by passing an {@link RpcQueryRequest }
     * @see [https://docs.near.org/api/rpc/contracts](https://docs.near.org/api/rpc/contracts)
     *
     */
    query<R extends Omit<RpcQueryResponse, 'block_hash' | 'block_height'>>(params: RpcQueryRequest): Promise<R & {
        block_hash: CryptoHash;
        block_height: number;
    }>;
    /**
     * Query changes in block from the RPC
     * pass block_id OR finality as blockQuery, not both
     * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
     */
    blockChanges(blockQuery: BlockReference): Promise<RpcStateChangesInBlockByTypeResponse>;
    /**
     * Gets the protocol config at a block from RPC
     *
     * @param blockReference specifies the block to get the protocol config for
     */
    experimental_protocolConfig(blockReference: BlockReference | {
        sync_checkpoint: 'genesis';
    }): Promise<RpcProtocolConfigResponse>;
    /**
     * Gets a light client execution proof for verifying execution outcomes
     * @see [https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof](https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof)
     */
    lightClientProof(request: LightClientProofRequest): Promise<RpcLightClientExecutionProofResponse>;
    /**
     * Returns the next light client block as far in the future as possible from the last known hash
     * to still be able to validate from that hash. This will either return the last block of the
     * next epoch, or the last final known block.
     *
     * @see [https://github.com/near/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-block](https://github.com/near/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-block)
     */
    nextLightClientBlock(request: NextLightClientBlockRequest): Promise<RpcLightClientNextBlockResponse>;
    /**
     * Gets access key changes for a given array of accountIds
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-all)
     */
    accessKeyChanges(accountIdArray: string[], blockQuery: BlockReference): Promise<RpcStateChangesInBlockResponse>;
    /**
     * Gets single access key changes for a given array of access keys
     * pass block_id OR finality as blockQuery, not both
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-single)
     */
    singleAccessKeyChanges(accessKeyArray: AccessKeyWithPublicKey[], blockQuery: BlockReference): Promise<RpcStateChangesInBlockResponse>;
    /**
     * Gets account changes for a given array of accountIds
     * pass block_id OR finality as blockQuery, not both
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-account-changes)
     */
    accountChanges(accountIdArray: string[], blockQuery: BlockReference): Promise<RpcStateChangesInBlockResponse>;
    /**
     * Gets contract state changes for a given array of accountIds
     * pass block_id OR finality as blockQuery, not both
     * Note: If you pass a keyPrefix it must be base64 encoded
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-state-changes)
     */
    contractStateChanges(accountIdArray: string[], blockQuery: BlockReference, keyPrefix?: string): Promise<RpcStateChangesInBlockResponse>;
    /**
     * Gets contract code changes for a given array of accountIds
     * pass block_id OR finality as blockQuery, not both
     * Note: Change is returned in a base64 encoded WASM file
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-code-changes)
     */
    contractCodeChanges(accountIdArray: string[], blockQuery: BlockReference): Promise<RpcStateChangesInBlockResponse>;
    /**
     * Directly call the RPC specifying the method and params
     *
     * @param method RPC method
     * @param params Parameters to the method
     */
    sendJsonRpc<Method extends keyof Methods, Params = Methods[Method]['request']['params'], Result = Extract<Methods[Method]['response'], {
        result: object;
    }>['result']>(method: Method, params: Params): Promise<Result>;
}
export {};
