/**
 * @module
 * @description
 * This module contains the {@link FailoverRpcProvider} client class
 * which can be used to interact with multiple [NEAR RPC APIs](https://docs.near.org/api/rpc/introduction).
 * @see {@link "@near-js/types".provider | provider} for a list of request and response types
 */
import { TypedError, } from '../types/index.js';
/**
 * Client class to interact with the [NEAR RPC API](https://docs.near.org/api/rpc/introduction).
 * @see [https://github.com/near/nearcore/tree/master/chain/jsonrpc](https://github.com/near/nearcore/tree/master/chain/jsonrpc)
 */
export class FailoverRpcProvider {
    /**
     * @param providers list of providers
     */
    constructor(providers) {
        if (providers.length === 0) {
            throw new Error('At least one provider must be specified');
        }
        this.providers = providers;
        this.currentProviderIndex = 0;
    }
    switchToNextProvider() {
        if (this.providers.length === 1)
            return;
        if (this.providers.length - 1 <= this.currentProviderIndex) {
            this.currentProviderIndex = 0;
        }
        else {
            this.currentProviderIndex += 1;
        }
    }
    get currentProvider() {
        const provider = this.providers[this.currentProviderIndex];
        if (!provider)
            throw new Error(`Provider wasn't found at index ${this.currentProviderIndex}`);
        return provider;
    }
    async withBackoff(getResult) {
        for (let i = 0; i < this.providers.length; i++) {
            try {
                // each provider implements own retry logic
                const result = await getResult(this.currentProvider);
                if (typeof result === 'undefined')
                    continue;
                return result;
            }
            catch (e) {
                console.error(e);
                this.switchToNextProvider();
            }
        }
        throw new TypedError(`Exceeded ${this.providers.length} providers to execute request`, 'RetriesExceeded');
    }
    async getNetworkId() {
        return this.withBackoff((currentProvider) => currentProvider.getNetworkId());
    }
    async getCurrentEpochSeatPrice() {
        return this.withBackoff((currentProvider) => currentProvider.getCurrentEpochSeatPrice());
    }
    async getNextEpochSeatPrice() {
        return this.withBackoff((currentProvider) => currentProvider.getNextEpochSeatPrice());
    }
    async viewAccessKey(params) {
        return this.withBackoff((currentProvider) => currentProvider.viewAccessKey(params));
    }
    async viewAccessKeyList(params) {
        return this.withBackoff((currentProvider) => currentProvider.viewAccessKeyList(params));
    }
    async viewAccount(params) {
        return this.withBackoff((currentProvider) => currentProvider.viewAccount(params));
    }
    async viewContractCode(params) {
        return this.withBackoff((currentProvider) => currentProvider.viewContractCode(params));
    }
    async viewGlobalContractCode(params) {
        return this.withBackoff((currentProvider) => currentProvider.viewGlobalContractCode(params));
    }
    async viewContractState(params) {
        return this.withBackoff((currentProvider) => currentProvider.viewContractState(params));
    }
    async callFunction(params) {
        return this.withBackoff((currentProvider) => currentProvider.callFunction(params));
    }
    async callFunctionRaw(params) {
        return this.withBackoff((currentProvider) => currentProvider.callFunctionRaw(params));
    }
    async viewBlock(blockQuery) {
        return this.withBackoff((currentProvider) => currentProvider.viewBlock(blockQuery));
    }
    async viewChunk(chunkId) {
        return this.withBackoff((currentProvider) => currentProvider.viewChunk(chunkId));
    }
    async viewGasPrice(blockId) {
        return this.withBackoff((currentProvider) => currentProvider.viewGasPrice(blockId));
    }
    async viewNodeStatus() {
        return this.withBackoff((currentProvider) => currentProvider.viewNodeStatus());
    }
    async viewValidators(params) {
        return this.withBackoff((currentProvider) => currentProvider.viewValidators(params));
    }
    async viewTransactionStatus(params) {
        return this.withBackoff((currentProvider) => currentProvider.viewTransactionStatus(params));
    }
    async viewTransactionStatusWithReceipts(params) {
        return this.withBackoff((currentProvider) => currentProvider.viewTransactionStatusWithReceipts(params));
    }
    async viewTransactionReceipt(receiptId) {
        return this.withBackoff((currentProvider) => currentProvider.viewTransactionReceipt(receiptId));
    }
    async sendTransactionUntil(signedTransaction, waitUntil) {
        return this.withBackoff((currentProvider) => currentProvider.sendTransactionUntil(signedTransaction, waitUntil));
    }
    /**
     * Sends a signed transaction to the RPC and waits until transaction is fully complete
     * @see [https://docs.near.org/docs/develop/front-end/rpc#send-transaction-await](https://docs.near.org/docs/develop/front-end/rpc#general-validator-status)
     *
     * @param signedTransaction The signed transaction being sent
     */
    async sendTransaction(signedTransaction) {
        return this.withBackoff((currentProvider) => currentProvider.sendTransaction(signedTransaction));
    }
    /**
     * Sends a signed transaction to the RPC and immediately returns transaction hash
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#send-transaction-async)
     * @param signedTransaction The signed transaction being sent
     */
    async sendTransactionAsync(signedTransaction) {
        return this.withBackoff((currentProvider) => currentProvider.sendTransactionAsync(signedTransaction));
    }
    /**
     * Query the RPC by passing an {@link RpcQueryRequest }
     * @see [https://docs.near.org/api/rpc/contracts](https://docs.near.org/api/rpc/contracts)
     *
     */
    async query(params) {
        return this.withBackoff((currentProvider) => currentProvider.query(params));
    }
    /**
     * Query changes in block from the RPC
     * pass block_id OR finality as blockQuery, not both
     * @see [https://docs.near.org/api/rpc/block-chunk](https://docs.near.org/api/rpc/block-chunk)
     */
    async blockChanges(blockQuery) {
        return this.withBackoff((currentProvider) => currentProvider.blockChanges(blockQuery));
    }
    /**
     * Gets the protocol config at a block from RPC
     *
     * @param blockReference specifies the block to get the protocol config for
     */
    async experimental_protocolConfig(blockReference) {
        return this.withBackoff((currentProvider) => currentProvider.experimental_protocolConfig(blockReference));
    }
    /**
     * Gets a light client execution proof for verifying execution outcomes
     * @see [https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof](https://github.com/nearprotocol/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-proof)
     */
    async lightClientProof(request) {
        return this.withBackoff((currentProvider) => currentProvider.lightClientProof(request));
    }
    /**
     * Returns the next light client block as far in the future as possible from the last known hash
     * to still be able to validate from that hash. This will either return the last block of the
     * next epoch, or the last final known block.
     *
     * @see [https://github.com/near/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-block](https://github.com/near/NEPs/blob/master/specs/ChainSpec/LightClient.md#light-client-block)
     */
    async nextLightClientBlock(request) {
        return this.withBackoff((currentProvider) => currentProvider.nextLightClientBlock(request));
    }
    /**
     * Gets access key changes for a given array of accountIds
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-all)
     */
    async accessKeyChanges(accountIdArray, blockQuery) {
        return this.withBackoff((currentProvider) => currentProvider.accessKeyChanges(accountIdArray, blockQuery));
    }
    /**
     * Gets single access key changes for a given array of access keys
     * pass block_id OR finality as blockQuery, not both
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-access-key-changes-single)
     */
    async singleAccessKeyChanges(accessKeyArray, blockQuery) {
        return this.withBackoff((currentProvider) => currentProvider.singleAccessKeyChanges(accessKeyArray, blockQuery));
    }
    /**
     * Gets account changes for a given array of accountIds
     * pass block_id OR finality as blockQuery, not both
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-account-changes)
     */
    async accountChanges(accountIdArray, blockQuery) {
        return this.withBackoff((currentProvider) => currentProvider.accountChanges(accountIdArray, blockQuery));
    }
    /**
     * Gets contract state changes for a given array of accountIds
     * pass block_id OR finality as blockQuery, not both
     * Note: If you pass a keyPrefix it must be base64 encoded
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-state-changes)
     */
    async contractStateChanges(accountIdArray, blockQuery, keyPrefix = '') {
        return this.withBackoff((currentProvider) => currentProvider.contractStateChanges(accountIdArray, blockQuery, keyPrefix));
    }
    /**
     * Gets contract code changes for a given array of accountIds
     * pass block_id OR finality as blockQuery, not both
     * Note: Change is returned in a base64 encoded WASM file
     * See [docs for more info](https://docs.near.org/docs/develop/front-end/rpc#view-contract-code-changes)
     */
    async contractCodeChanges(accountIdArray, blockQuery) {
        return this.withBackoff((currentProvider) => currentProvider.contractCodeChanges(accountIdArray, blockQuery));
    }
}
