import { sha256 } from '@noble/hashes/sha2.js';
import { KeyType } from '../crypto/index.js';
import { serializeMessage } from '../nep413/schema.js';
import { encodeDelegateAction, encodeTransaction, Signature, SignedDelegate, SignedTransaction, } from '../transactions/index.js';
/**
 * General signing interface, can be used for in memory signing, RPC singing, external wallet, HSM, etc.
 *
 * The signer must return a valid PublicKey from `getPublicKey()`, and must implement raw byte signing
 * that can be verified with the corresponding public key. (To verify the signature, serialize and hash transaction/delegate action,
 * or get payload hash for NEP-413 message from `utils.ts` and verify with the public key).
 */
export class Signer {
    /**
     * Signs given message according to NEP-413 requirements
     * @see https://github.com/near/NEPs/blob/master/neps/nep-0413.md
     *
     * @param accountId - The account name to which the public key corresponds (e.g. "alice.near").
     * @param params - The parameters including message, recipient, nonce, and optional callbackUrl.
     */
    async signNep413Message(accountId, params) {
        if (params.nonce.length !== 32)
            throw new Error('Nonce must be exactly 32 bytes long');
        const hash = serializeMessage(params);
        const signature = await this.signBytes(hash);
        return {
            accountId: accountId,
            publicKey: await this.getPublicKey(),
            signature: signature,
            state: params.callbackUrl,
        };
    }
    /**
     * Signs given transaction.
     * @param transaction - The transaction to sign.
     * @returns {Promise<[Uint8Array, SignedTransaction]>} - Promise of the hash that can be verified and signed transaction.
     */
    async signTransaction(transaction) {
        const pk = await this.getPublicKey();
        if (transaction.publicKey.toString() !== pk.toString())
            throw new Error("The public key doesn't match the signer's key");
        const serializedTx = encodeTransaction(transaction);
        const txHash = new Uint8Array(sha256(serializedTx));
        const signature = await this.signBytes(txHash);
        const signedTx = new SignedTransaction({
            transaction,
            signature: new Signature({
                keyType: transaction.publicKey.ed25519Key ? KeyType.ED25519 : KeyType.SECP256K1,
                data: signature,
            }),
        });
        return { txHash, signedTransaction: signedTx };
    }
    /**
     * Signs given delegate action.
     * @param delegateAction - The delegate action to sign.
     * @returns {Promise<[Uint8Array, SignedDelegate]>} - Promise of the hash that can be verified and signed delegate action.
     */
    async signDelegateAction(delegateAction) {
        const pk = await this.getPublicKey();
        if (delegateAction.publicKey.toString() !== pk.toString())
            throw new Error("The public key doesn't match the signer's key");
        const serializedDelegate = encodeDelegateAction(delegateAction);
        const delegateHash = new Uint8Array(sha256(serializedDelegate));
        const signature = await this.signBytes(delegateHash);
        const signedDelegate = new SignedDelegate({
            delegateAction,
            signature: new Signature({
                keyType: pk.keyType,
                data: signature,
            }),
        });
        return { delegateHash, signedDelegate };
    }
}
