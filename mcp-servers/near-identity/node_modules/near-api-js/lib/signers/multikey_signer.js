import { KeyPair } from '../crypto/index.js';
import { KeyPairSigner } from './key_pair_signer.js';
import { Signer } from './signer.js';
/**
 * Signs using Multiple Keys, rotating through them for parallel transaction signing.
 *
 * This signer is designed for high-throughput scenarios where you want to sign
 * multiple transactions in parallel using different keys (to avoid nonce conflicts).
 *
 * @example
 * ```ts
 * const signer = new MultiKeySigner([key1, key2, key3]);
 * const account = new Account('account.near', provider, signer);
 *
 * // These will use different keys in rotation
 * await Promise.all([
 *   account.transfer({ receiverId: 'bob.near', amount: 1n }),
 *   account.transfer({ receiverId: 'alice.near', amount: 2n }),
 *   account.transfer({ receiverId: 'carol.near', amount: 3n }),
 * ]);
 * ```
 */
export class MultiKeySigner extends Signer {
    constructor(keys) {
        super();
        this.keyIndex = 0;
        if (keys.length === 0) {
            throw new Error('MultiKeySigner requires at least one key');
        }
        this.keys = keys;
    }
    static fromSecretKeys(encodedKeys) {
        const keys = encodedKeys.map(KeyPair.fromString);
        return new MultiKeySigner(keys);
    }
    /**
     * Returns the next public key in rotation.
     * Each call rotates to the next key, enabling parallel transaction creation
     * where each transaction gets a different key.
     */
    async getPublicKey() {
        const key = this.keys[this.keyIndex];
        this.keyIndex = (this.keyIndex + 1) % this.keys.length;
        return key.getPublicKey();
    }
    /**
     * Find the key pair that matches a given public key.
     */
    findKeyByPublicKey(publicKey) {
        const pkString = publicKey.toString();
        const key = this.keys.find((k) => k.getPublicKey().toString() === pkString);
        if (!key) {
            throw new Error(`No matching key found for public key ${pkString}. ` +
                `Available keys: ${this.keys.map((k) => k.getPublicKey().toString()).join(', ')}`);
        }
        return key;
    }
    async signBytes(_bytes) {
        throw new Error('MultiKeySigner does not support signBytes directly. Use signTransaction or signDelegateAction instead.');
    }
    /**
     * Signs a NEP-413 message using the first key in the set.
     * This is because NEP-413 messages are not typically parallelized,
     * so we use a consistent key for signing.
     */
    async signNep413Message(accountId, params) {
        const signer = new KeyPairSigner(this.keys[0]);
        return signer.signNep413Message(accountId, params);
    }
    /**
     * Signs a transaction using the key that matches the transaction's public key.
     * This ensures parallel transactions each get signed with the correct key.
     */
    async signTransaction(transaction) {
        const key = this.findKeyByPublicKey(transaction.publicKey);
        const signer = new KeyPairSigner(key);
        return signer.signTransaction(transaction);
    }
    /**
     * Signs a delegate action using the key that matches the action's public key.
     * This ensures parallel meta-transactions each get signed with the correct key.
     */
    async signDelegateAction(delegateAction) {
        const key = this.findKeyByPublicKey(delegateAction.publicKey);
        const signer = new KeyPairSigner(key);
        return signer.signDelegateAction(delegateAction);
    }
}
