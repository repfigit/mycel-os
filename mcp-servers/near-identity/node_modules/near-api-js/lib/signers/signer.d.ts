import { type PublicKey } from '../crypto/index.js';
import { type MessagePayload } from '../nep413/schema.js';
import { type DelegateAction, SignedDelegate, SignedTransaction, type Transaction } from '../transactions/index.js';
export interface SignedMessage {
    accountId: string;
    publicKey: PublicKey;
    signature: Uint8Array;
    state?: string;
}
export interface SignTransactionReturn {
    txHash: Uint8Array;
    signedTransaction: SignedTransaction;
}
export interface SignDelegateActionReturn {
    delegateHash: Uint8Array;
    signedDelegate: SignedDelegate;
}
/**
 * General signing interface, can be used for in memory signing, RPC singing, external wallet, HSM, etc.
 *
 * The signer must return a valid PublicKey from `getPublicKey()`, and must implement raw byte signing
 * that can be verified with the corresponding public key. (To verify the signature, serialize and hash transaction/delegate action,
 * or get payload hash for NEP-413 message from `utils.ts` and verify with the public key).
 */
export declare abstract class Signer {
    /**
     * Returns public key for given signer
     */
    abstract getPublicKey(): Promise<PublicKey>;
    /**
     * Implement this method to sign given bytes payload.
     * @param bytes - The payload to sign.
     * @returns {Promise<Uint8Array>} - Promise of the bytes representation of the signature.
     */
    protected abstract signBytes(bytes: Uint8Array): Promise<Uint8Array>;
    /**
     * Signs given message according to NEP-413 requirements
     * @see https://github.com/near/NEPs/blob/master/neps/nep-0413.md
     *
     * @param accountId - The account name to which the public key corresponds (e.g. "alice.near").
     * @param params - The parameters including message, recipient, nonce, and optional callbackUrl.
     */
    signNep413Message(accountId: string, params: MessagePayload): Promise<SignedMessage>;
    /**
     * Signs given transaction.
     * @param transaction - The transaction to sign.
     * @returns {Promise<[Uint8Array, SignedTransaction]>} - Promise of the hash that can be verified and signed transaction.
     */
    signTransaction(transaction: Transaction): Promise<SignTransactionReturn>;
    /**
     * Signs given delegate action.
     * @param delegateAction - The delegate action to sign.
     * @returns {Promise<[Uint8Array, SignedDelegate]>} - Promise of the hash that can be verified and signed delegate action.
     */
    signDelegateAction(delegateAction: DelegateAction): Promise<SignDelegateActionReturn>;
}
